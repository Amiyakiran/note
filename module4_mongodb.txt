MODULE -IV
----------

MONGODB
-----------
Sql Vs NoSql
-----------
SQL (Structured Query Language) and NoSQL (Not Only SQL) are two broad categories of database management systems, each with its own set of characteristics, advantages, and use cases.

SQL (Relational Databases)
-------------------------
Data Structure :  SQL databases are relational and follow a predefined schema.
		  Data is organized into tables, with rows representing individual records and columns representing attributes.

Schema:		  Schema is rigid and must be defined before data is inserted.
		  Changes to the schema can be complex and require careful management.

Transactions:     Support for ACID (Atomicity, Consistency, Isolation, Durability) transactions ensures data integrity.

Use Cases:	  Well-suited for applications with complex relationships between data.
		  Commonly used for financial systems, enterprise applications, and systems where data integrity is crucial.

Examples:	 MySQL, PostgreSQL, Oracle, Microsoft SQL Server.


NoSQL (Non-relational Databases):
---------------------------------
Data Structure:		NoSQL databases can have various data models, including document-oriented, key-value pairs, wide-column stores, or graph databases.
			The data structure is more flexible, allowing for dynamic and evolving schemas.

Schema:			Schema-less or schema-flexible, enabling easy addition or removal of fields without requiring a predefined structure.

Transactions:		NoSQL databases may sacrifice full ACID transactions for improved performance and scalability.
			Some NoSQL databases provide eventual consistency.

Use Cases:		Well-suited for applications with constantly changing data, high write loads, and scalability requirements.
			Commonly used in big data, real-time web applications, and projects where rapid development and iteration are essential.

Examples:		MongoDB (document-oriented), Cassandra (wide-column store), Redis (key-value), Neo4j (graph).


MONGODB (NoSQL)
---------------
In MongoDB, data is organized into collections, and each document within a collection is a JSON-like BSON(Binary JSON) object.

STRUCTURE
---------
 - A MongoDB deployment can contain multiple databases.Each database contains one or more collections.
 - A collection is a group of MongoDB documents.(equivalent to tables in relational databases But with different schema)
 - A document is a basic unit of data in MongoDB which contains fields, and it is equivalent to a record in a relational database
 - A field is a key-value pair within a document
     - Fields can be of various types, including strings, numbers, arrays, nested documents, etc.
 - A subdocument is a document nested within another document
 - Each document in a MongoDB collection has a unique identifier called an ObjectId



- Local mongodb is called mongodb compass
- cloud mongodb is - mongodb atlas


 Operations
----------------
 commands
     --------
     - open _MONGOSH (mongodb shell)
     
     1) show databases - list out all databases inside your mongodb.
     2) use db_name - to change directory/database.
     3) show collections - to get all collections inside a database.
     4) db.collectionName.find() - to get all documents inside particular collection
     5) db.users.findOne({condition}) - to get a particular document satisfing the condition 
     6) db.users.find().limit(number) - get a particular number of documents.
     7) db.users.find().sort({username:-1}) - sort in descending order
     8) db.users.find().sort({username:1}) - sort in ascending order

     9) db.users.insertOne({username:"neel",email:"neel@gmail.com",password:"neel123",profile:"",github:"",linkedin:""}) - to add new document in a collection.

     10) db.users.insertMany([{username:"sicily",email:"sicily@gmail.com",password:'sicily123',profile:"",github:"",linkedin:""},{username:"Mini",email:"mini@gmail.com",password:"mini123",profile:"",github:"",linkedin:""}])
     
     11) db.users.insertMany([{uname:'jacob',age:18,debt:2000,balance:2600},{uname:'kavi',age:25,debt:12000,balance:50000}])

     12) db.users.insertOne({uname:'kyle',age:30 ,address:{city:'washington DC',zipcode:7896},hobbies:["gamming",'coding',"Driving"]})
 
     13) query based -
            - db.users.find({age:{$lt:25}}) - less than
            - db.users.find({age:{$lte:25}}) - less than or equal to
            - db.users.find({age:{$gt:25}}) - greater than
            - db.users.find({age:{$gte:25}}) - greater than or equal to
            - db.users.find({$or:[{age:{$gt:25}},{age:{$gt:30}}]}) - anyone condition to be true
            - db.users.find({$and:[{age:{$gt:17}},{age:{$lt:30}}]}) - both condition should  be true
            - db.users.find({address:{$exists:true}}) - return the document which have the key
            - db.users.find({address:{$exists:false}}) - return the document which doesnot have the key

            - to compare two keys within the document - $expr

               - db.users.find({$expr:{$gt:["$balance","$debt"]}}) - balance>debt
               - db.users.find({$expr:{$gt:["$debt","$balance"]}}) - debt>balance

      14) update

          - syntax = db.collectionName.updateOne({condition to unqiuly identify the document},{condition to update the document})

          - db.users.updateOne({uname:"jacob"},{$inc:{age:2}}) - increment
          - db.users.updateOne({uname:"jacob"},{$inc:{age:-2}}) - decrement
          - db.users.updateOne({uname:'kyle'},{$push:{hobbies:"cycling"}}) -add a new hobby to user kyle.
          - db.your_collection_name.updateOne({ name:"kyle" },{ $set: { "address.code": 8888 } }) - update a key inside a object
          - db.students.updateOne({name:'kyle'},{$unset:{code:""}})- to remove a particular key from document


      15)delete
          - db.users.deleteOne({uname:"jacob"})  - delete one document
          - db.users.deleteMany({uname:{$exists:true}}) - delete more than one document  

      16) Aggregation operations process multiple documents and return computed results.
          ----------------------
          -Group values from multiple documents together.
           syntax
              {
                  $lookup:
                  {
                     from: <collection to join>,
                     localField: <field from the input documents>,
                     foreignField: <field from the documents of the "from" collection>,
                     as: <output array field>
                  }
               }

         - db.users.aggregate({$lookup:{from:'projects',localField:'_id',foreignField:'userId',as:'userProject'}})
         - both localField and ForeignField should have same value then only joing happens.


creating project in  Mongodb atlas - cloud based
   ---------------
   1) create project.
   2) give project name.
   3) no change to ownership then click create project.
   4) click database in the sidebar.
   5) click build a dataBase the choose free option. then click create.
   6) change a password - make it as simple as possible without special characters
   7) click create user
   8) click finish and click go to overview.            
   9) again click database in the sidebar.
   10) click browse collections
   11) click my own data.
   12) give database name and collection name then click create button
   13) click network access in the sidebar then click edit button
   14) click allow access from anywhere button - so that anyone can access the database.

   15) click the connect and then the driver
   16) copy the connection string and paste it in the .env file
   17) update the string by giving the password of the corresponding database and the name of the database after the slash and before the question mark.
 


Mongoose 
--------
   - it is a node.js library used to connect the server with the database.
   - installation command - npm i mongoose
   - access the connectionstring from process.env file
   - connect server with the mongodb using connect function of mongoose.
   - import connection.js file in index.js inorder to execute it.
   - inorder to save the data in the mongodb use save() method in mongoose.

schema
------
- Each schema maps to a MongoDB collection and defines the shape of the documents within that collection
- create schema using the schema class in the mongoose library
- syntax
  -----
  const schemaNAME = new mongoose.schema({
  key:value
 })
- in order to access the schema it have to be converted into model
- validation can be given to scheme using validator module 
    - install - npm i validator

   modal
   -----
   - modal  is created using modal function in mongoose 
 - syntax
   ------
   const modelName = mongoose.model('collectionName', schemaName);
  - export modal inorder to access in other pages like controller if written in separate pages.
 



DATABASE 
--------
A database is an organized collection of data that is stored and managed in a way that makes it easy to retrieve, update, and manipulate.

Types of databases include:
---------------------------
1) Relational Database (RDBMS)1
- it store data in tables with rows and columns and use SQL (Structured Query Language) to manage and manipulate data.
eg: MySQL, PostgreSQL, Oracle, and SQL Server.

SELECT: Retrieves data from the database.
INSERT INTO: Adds new data to the database.
UPDATE: Modifies existing data.
DELETE: Removes data from the database.

SELECT * FROM Employees;
This will return all rows and columns in the table.


To get only employees from the "HR" department:

sql
Copy
SELECT FirstName, LastName FROM Employees WHERE Department = 'HR';


To add a new employee to the "Employees" table:

sql
Copy
INSERT INTO Employees (EmployeeID, FirstName, LastName, Age, Department)
VALUES (4, 'Alice', 'Williams', 29, 'Finance');


3. UPDATE - Modifying data
If you want to change the department of the employee with EmployeeID = 2:

sql
Copy
UPDATE Employees
SET Department = 'Sales'
WHERE EmployeeID = 2;


4. DELETE - Removing data
To delete an employee with EmployeeID = 3:

sql
Copy
DELETE FROM Employees
WHERE EmployeeID = 3;


Table: Employees
EmployeeID	FirstName	LastName	Age	Department
1	          John	           Doe	        28	HR
2	          Jane	           Smith	34	IT
3	          Bob	           Johnson	25	Marketing



2) NoSQL Databases: designed for unstructured data, scalability, and flexibility in data storage, especially for big data and real-time applications.
eg:MongoDB, Cassandra, and Redis,



MongoDB is a document database which is often referred to as a non-relational database. This does not mean that relational data cannot be stored in document databases. It means that relational data is stored differently. A better way to refer to it is as a non-tabular database.


 In MongoDB, instead of tables these are called collections.


In MongoDB, the data is stored in a different format compared to relational databases like SQL. MongoDB is a NoSQL database, and it stores data in documents (similar to JSON objects) rather than tables and rows.

Let's convert the same "Employees" data you mentioned earlier into MongoDB's document format.

Example of Data in MongoDB:
In MongoDB, data is stored in collections (similar to tables in SQL), and each document is a record (similar to a row in SQL). Each document is a set of key-value pairs.

MongoDB Collection: employees
Here’s how the data would be represented in MongoDB as a document:

json
Copy
{
  "_id": ObjectId("unique-id-1"),
  "EmployeeID": 1,
  "FirstName": "John",
  "LastName": "Doe",
  "Age": 28,
  "Department": "HR"
},
{
  "_id": ObjectId("unique-id-2"),
  "EmployeeID": 2,
  "FirstName": "Jane",
  "LastName": "Smith",
  "Age": 34,
  "Department": "IT"
},
{
  "_id": ObjectId("unique-id-3"),
  "EmployeeID": 3,
  "FirstName": "Bob",
  "LastName": "Johnson",
  "Age": 25,
  "Department": "Marketing"
}
Key Differences Between SQL and MongoDB Storage:
Documents vs. Tables:

In MongoDB, each employee record is a document in a collection. Each document is self-contained with all the data about that employee.
In SQL, the data is stored in a structured table format with rows and columns.
Data Representation:

In MongoDB, each document is stored as a BSON (Binary JSON) object. This is similar to a JSON format, which allows more flexibility in the structure of the data (e.g., nested objects, arrays).
In SQL, each row corresponds to a record, and each column corresponds to an attribute (field) of the record.
No Fixed Schema:

MongoDB doesn't enforce a rigid schema, meaning each document in a collection can have a different structure (e.g., some documents might have additional fields that others don't). This is unlike SQL, where every row must follow the table’s defined schema.
Example MongoDB Operations
Here are equivalent MongoDB operations to the SQL examples I gave earlier.

1. Insert Data (equivalent to SQL INSERT)
To insert a new employee into the employees collection in MongoDB, you would use the insertOne() method:

javascript
Copy
db.employees.insertOne({
  EmployeeID: 4,
  FirstName: "Alice",
  LastName: "Williams",
  Age: 29,
  Department: "Finance"
});
2. Find Data (equivalent to SQL SELECT)
To find all employees:

javascript
Copy
db.employees.find();
To find employees in the "HR" department:

javascript
Copy
db.employees.find({ Department: "HR" });
3. Update Data (equivalent to SQL UPDATE)
To update an employee's department:

javascript
Copy
db.employees.updateOne(
  { EmployeeID: 2 },
  { $set: { Department: "Sales" } }
);
4. Delete Data (equivalent to SQL DELETE)
To delete an employee with EmployeeID = 3:

javascript
Copy
db.employees.deleteOne({ EmployeeID: 3 });
Conclusion:
In MongoDB, the same data is stored as documents in a collection. The structure is more flexible compared to SQL databases, where data is stored in tables with a fixed schema. MongoDB's document-based approach makes it suitable for applications that require scalability and flexibility, especially when handling unstructured or semi-structured data.




The ObjectId is a 12-byte identifier that ensures uniqueness. It is often represented in hexadecimal form (e.g., "605c72ef15320723e5b78f56"), which MongoDB uses for indexing and as a primary key.


Data Types: In BSON, there are additional types not present in standard JSON, such as:

ObjectId: A unique identifier (used in _id).
Date: BSON can store date objects.
Binary: BSON can store binary data, like images or files.



How BSON Differs from JSON:
ObjectId: As mentioned, MongoDB automatically generates a unique ObjectId for each document if you don’t provide one, which is not present in JSON.

Binary Data: BSON supports binary data types, such as BinData, which JSON does not.

More Data Types: BSON allows for additional types like Date, RegEx (regular expressions), and Int64, which are not directly supported in JSON.


BSON (Binary JSON) is a binary-encoded serialization format used by MongoDB to store data, supporting more data types and offering efficient storage and retrieval compared to standard JSON.

Serialization is the process of converting data structures or objects into a format that can be easily stored (in a file or database) or transmitted (over a network).
Binary encoding means that the data is stored in binary form (as 1s and 0s), which is more efficient than text-based formats like JSON.
Example:
A simple text-based format (like JSON) might represent a number as "age": 25.
In BSON (binary), the number 25 would be encoded in binary, consuming less space and making it quicker to process.



Indexing in MongoDB is a technique used to improve the speed and performance of database queries. It helps MongoDB locate and retrieve documents more quickly by maintaining an ordered structure of specific fields in the database. Without indexing, MongoDB would need to scan every document in a collection to find the ones matching a query, which could be inefficient, especially for large datasets.


